import os
import os.path as osp
import shutil
from ast import AST, ClassDef, FunctionDef, Import, ImportFrom, NodeTransformer
from collections import defaultdict
from typing import Callable, Dict, List, Optional, Union

import astor
from astpretty import pprint  # for pdb debug

from .parse import Parser
from .utils import cd

__all__ = ["FileLevelCodeGenerator", "SegmentCodeGenerator"]

CODEGEN_PREFIX = "# Generated by CodeSlim\n"


def _is_file_exist(dir, filename):
    return osp.exists(osp.join(dir, filename))


def _get_file_name(file_path):
    file = osp.basename(file_path).split(".")[:-1]
    return ".".join(file)


# Copy lines or generating code from AST node?
# It seems that generating code form AST node is more
# convenient for rewriting, for instance,
# import modules from refactored file structures,
# inheriting from rewritten base class...
class CodeGenerator:
    def generate(self):
        raise NotImplemented

    def _generate_from_str(self, filename, contends: Optional[List[str]] = None):
        with open(filename, "w") as f:
            f.writelines(CODEGEN_PREFIX)
            if contends:
                for c in contends:
                    f.writelines(c)

    def _generate_from_ast(self, filename, ast):
        source_code = astor.to_source(ast)
        with open(filename, "w") as f:
            f.writelines(CODEGEN_PREFIX)
            f.write(source_code)

    def generate_init(self, target_path, force=False):
        if not force and _is_file_exist(target_path, "__init__.py"):
            raise RuntimeError("__init__.py exists!")
        path = osp.join(target_path, "__init__.py")
        self._generate_from_str(path)

    def rewrite_imports(self, ast, module_mapper):
        raise NotImplemented

    def copy_file(self, source_file, target_dir, force=False):
        if not force and _is_file_exist(target_dir, osp.basename(source_file)):
            raise RuntimeError(f"{source_file} exists!")
        shutil.copy(source_file, target_dir)

    def makedirs(self, path):
        os.makedirs(path, exist_ok=True)

    # Do we need to fotmat generated code?
    def format(self, file_path):
        pass


class Rewriter(NodeTransformer):
    def __init__(self, targets: Dict[str, Callable]):
        for name, func in targets.items():
            setattr(self, "visit_" + name, func)


class FileLevelCodeGenerator(CodeGenerator):
    def __init__(
            self, target_dir, parser: Parser, module_mapper: Optional[Dict[str, str]] = None, custom_rewriter: Optional[Dict[str, Callable]] = None
    ):
        self.target_dir = target_dir
        self.parsers = parser.get_parsers()
        self.module_mapper = module_mapper or {}
        self.custom_rewriter = custom_rewriter
        self.rewriter = Rewriter(self._get_rewriter())
        self.imports_info = self._get_imports_info(parser.relations)
        self.cur_info = None

    def _get_imports_info(self, relation):
        extra_info = defaultdict(list)
        for file, target_file in relation.items():
            for f in target_file:
                extra_info[f].append(file)
        return extra_info 

    def _get_rewriter(self):
        rewrite_funcs = {"Import": self.rewrite_imports, "ImportFrom": self.rewrite_imports}
        if self.custom_rewriter is not None:
            rewrite_funcs.update(self.custom_rewriter)
        return rewrite_funcs

    def _preprocess(self, file, parser):
        pass

    def _postprocess(self):
        pass

    def generate(self):
        self.makedirs(self.target_dir)
        with cd(self.target_dir):
            for file, parser in self.parsers.items():
                file_name = osp.basename(parser.file_name)
                # TODO(Asthestarsfalll): need to process __init__ file
                if file_name == "__init__.py":
                    continue
                self._preprocess(file, parser)
                self.rewriter.visit(parser.ast)
                self._postprocess()
                self._generate_from_ast(file_name, parser.ast)

    def rewrite_imports(self, node: Union[ImportFrom, Import]) -> AST:
        if isinstance(node, ImportFrom) and hasattr(node, "is_target"):
            module_name = node.module
            if module_name in self.module_mapper:
                module_name = self.module_mapper[module_name]
            else:
                # need automatically get the file where the imported module belongs to
                module_name = module_name.split(".")[-1]
            node.module = module_name

        return node


class SegmentCodeGenerator(FileLevelCodeGenerator):

    def _get_rewriter(self):
        rewrite_funcs = {
                "Import": self.rewrite_imports, 
                "ImportFrom": self.rewrite_imports, 
                'FunctionDef': self.rewrite_defs, 
                'ClassDef': self.rewrite_defs
        }
        if self.custom_rewriter is not None:
            rewrite_funcs.update(self.custom_rewriter)
        return rewrite_funcs
    
    def _analyze_local_calls(self, parser):
        calls = parser._calls
        defs = parser._local_defs
        local_used = []
        # TODO(Asthestarsfalll): reduce the size of calls
        if calls and defs:
            # TODO(Asthestarsfalll): need more logic to tackle complex situation.
            for name, call in calls.items():
                if name in defs:
                    local_used.append(name)
        return local_used

    def _preprocess(self, file, parser):
        extern_uesd = []
        for i in self.imports_info[file]:
            p = self.parsers[i]
            extern_uesd += p.get_target_import_names()
        self.extern_used = extern_uesd
        self.local_used = self._analyze_local_calls(parser)

    def rewrite_defs(self, node: Union[FunctionDef, ClassDef]):
        if node.name not in self.extern_used and node.name not in self.local_used:
            return None
        return node
